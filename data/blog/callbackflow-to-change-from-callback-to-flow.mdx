---
title: 'D√πng callbackFlow ƒë·ªÉ chuy·ªÉn callback v·ªÅ flow v√† v√≠ d·ª• v·ªÅ location'
date: '2025-12-09'
lastmod: '2025-12-09'
tags: ['android', 'code', 'flow', 'location']
draft: false
summary: 'D√πng callbackFlow ƒë·ªÉ chuy·ªÉn callback v·ªÅ flow v√† v√≠ d·ª• v·ªÅ location'
images: ['/static/images/twitter-card.png']
---

Trong c√°c ·ª©ng d·ª•ng nh∆∞:
- Delivery
- Tracking
- Fitness
- Map
- IOT realtime
vi·ªác l·∫Øng nghe v·ªã tr√≠ (location) theo th·ªùi gian th·ª±c l√† y√™u c·∫ßu b·∫Øt bu·ªôc.


--- 

## V√¨ Sao N√™n D√πng callbackFlow Cho Location

Location API c·ªßa Android l√† callback-based
Trong khi UI hi·ªán ƒë·∫°i d√πng Kotlin Flow.
üëâ ```callbackFlow``` sinh ra ƒë·ªÉ b·ªçc callback th√†nh Flow chu·∫©n lifecycle.

‚úÖ T·ª± ƒë·ªông h·ªßy khi kh√¥ng c√≤n collector
‚úÖ Kh√¥ng c·∫ßn start()/stop()
‚úÖ Kh√¥ng leak
‚úÖ Cold Flow ‚Äì ch·ªâ ch·∫°y khi UI collect
‚úÖ Chu·∫©n Clean Architecture

## Data Layer ‚Äì Location DataSource V·ªõi callbackFlow

***Interface***
```kotlin
interface LocationDataSource {
    fun observeLocation(): Flow<Location>
}
```

***Implementation***
```kotlin
    class LocationDataSourceImpl @Inject constructor(
        @ApplicationContext private val context: Context
    ) : LocationDataSource {

        private val client =
            LocationServices.getFusedLocationProviderClient(context)

        override fun observeLocation(): Flow<Location> = callbackFlow {

            val request = LocationRequest.Builder(
                Priority.PRIORITY_HIGH_ACCURACY,
                2000L
            ).build()

            val callback = object : LocationCallback() {
                override fun onLocationResult(result: LocationResult) {
                    result.lastLocation?.let { location ->
                        trySend(location)
                    }
                }
            }

            client.requestLocationUpdates(
                request,
                callback,
                Looper.getMainLooper()
            )

            // Auto cancel when no longer collected
            awaitClose {
                client.removeLocationUpdates(callback)
            }
        }
    }
```

## Domain Layer ‚Äì Location Repository

***Interface***
```kotlin
interface LocationRepository {
    fun observeLocation(): Flow<GeoLocation>
}
```

***Implementation***
```kotlin
class LocationRepositoryImpl @Inject constructor(
    private val dataSource: LocationDataSource
) : LocationRepository {

    // Mapping Location to GeoLocation domain model
    override fun observeLocation(): Flow<GeoLocation> =
        dataSource.observeLocation()
            .map { it.toDomain() }
}
```

## Presentation Layer ‚Äì ViewModel

```kotlin
@HiltViewModel
class LocationViewModel @Inject constructor(
    private val observeLocation: ObserveLocationUseCase
) : ViewModel() {

    private val _location = MutableStateFlow<GeoLocation?>(null)
    val location = _location.asStateFlow()

    private var started = false

    fun startLocationUpdates() {
        if (started) return
        started = true

        viewModelScope.launch {
            observeLocation().collect { geo ->
                _location.value = geo
            }
        }
    }
}
```

## Presentation Layer ‚Äì Composable

Khai b√°o trong AndroidManifest.xml
```xml
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
```

```kotlin
@Composable
fun SearchScreenContainer(viewModel: LocationViewModel = hiltViewModel()) {
    val location by viewModel.location.collectAsState()
    LocationScreen(location)
}

@Composable
fun LocationScreen(
    location: GeoLocation?
) {
    val context = LocalContext.current

    var hasLocationPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED &&
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED
        )
    }

    val permissionLauncher =
        rememberLauncherForActivityResult(
            contract = ActivityResultContracts.RequestMultiplePermissions()
        ) { permissions ->
            val granted =
                permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true ||
                permissions[Manifest.permission.ACCESS_COARSE_LOCATION] == true

            hasLocationPermission = granted

            if (granted) {
                viewModel.startLocationUpdates()
            }
        }

    LaunchedEffect(Unit) {
        if (hasLocationPermission) {
            viewModel.startLocationUpdates()
        } else {
            permissionLauncher.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        }
    }

    if (!hasLocationPermission) {
        PermissionDeniedUI {
            permissionLauncher.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        }
    } else {
        LocationContent(location)
    }
}
```

```kotlin
@Composable
fun PermissionDeniedUI(
    onRequestPermission: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("·ª®ng d·ª•ng c·∫ßn quy·ªÅn v·ªã tr√≠ ƒë·ªÉ ho·∫°t ƒë·ªông.")
        Spacer(Modifier.height(12.dp))
        Button(onClick = onRequestPermission) {
            Text("C·∫•p quy·ªÅn")
        }
    }
}
```

```kotlin
@Composable
fun LocationContent(location: GeoLocation?) {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        if (location != null) {
            Text("Latitude: ${location.latitude}")
            Text("Longitude: ${location.longitude}")
        } else {
            Text("ƒêang l·∫•y v·ªã tr√≠...")
        }
    }
}
```


## K·∫øt Lu·∫≠n
S·ª≠ d·ª•ng ```callbackFlow``` ƒë·ªÉ chuy·ªÉn callback-based API (nh∆∞ Location API) sang Flow gi√∫p code tr·ªü n√™n s·∫°ch s·∫Ω, d·ªÖ b·∫£o tr√¨ v√† tu√¢n th·ªß c√°c nguy√™n t·∫Øc c·ªßa Clean Architecture. ƒêi·ªÅu n√†y ƒë·∫∑c bi·ªát h·ªØu √≠ch trong c√°c ·ª©ng d·ª•ng y√™u c·∫ßu c·∫≠p nh·∫≠t v·ªã tr√≠ theo th·ªùi gian th·ª±c. B√™n c·∫°nh ƒë√≥ c≈©ng c√≥ th·ªÉ √°p d·ª•ng t∆∞∆°ng t·ª± cho c√°c API callback-based kh√°c nh∆∞ Sensor, Bluetooth, Network, v.v.
