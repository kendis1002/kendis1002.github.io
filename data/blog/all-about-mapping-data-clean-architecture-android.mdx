---
title: 'Mapping data trong Android với clean architecture'
date: '2025-05-14'
lastmod: '2025-05-14'
tags: ['android', 'architecture']
draft: false
summary: 'Mapping data trong Android với clean architecture'
images: ['/static/images/twitter-card.png']
---

Trong các dự án Android hiện đại, đặc biệt khi áp dụng Clean Architecture, việc mapping dữ liệu giữa các tầng Data, Domain và Presentation là một bước bắt buộc nếu muốn giữ cho kiến trúc thật sự "clean", dễ bảo trì và dễ test.

Bài viết này sẽ hướng dẫn bạn:

- Vì sao cần mapping dữ liệu giữa các tầng.
- Vai trò của từng tầng trong mapping.
- Template code đầy đủ.
- Cấu trúc thư mục gợi ý và một số lưu ý.

---

## Vì sao cần mapping dữ liệu giữa các tầng?

Trong Clean Architecture, mỗi tầng có nhiệm vụ riêng và không nên “rò rỉ” model sang tầng khác:

- **Data Layer**: Làm việc với dữ liệu từ API, database (DTO – Data Transfer Object).
- **Domain Layer**: Chứa logic nghiệp vụ, Domain Model (thuần Kotlin, không phụ thuộc framework).
- **Presentation Layer**: Xử lý UI, hiển thị dữ liệu (UI Model – có thể chứa định dạng hiển thị).

Domain là lớp trung gian nghiệp vụ. 2 layer còn lại sẽ phụ thuộc vào Domain. Domain sẽ hoàn toàn độc lập. 

Nếu không mapping:

Domain có thể bị “bẩn” bởi chi tiết của API.
UI có thể bị gò bó vì Domain Model không phù hợp để hiển thị trực tiếp.
Việc thay đổi API hoặc UI có thể gây ảnh hưởng dây chuyền.

---

## Vai trò mapping của từng layer

###Data Layer

Mapping DTO ↔ Domain.
DTO không được xuất hiện ngoài Data Layer.

Ví dụ: UserDTO.toDomain().

###Domain Layer

Không chứa mapper ra Presentation.
Có thể có mapper ngược về Data nếu cần gửi request (Domain → DTO).

###Presentation Layer

Mapping Domain → UI Model.
Thêm field phục vụ UI (ví dụ định dạng text, style).

Ví dụ: User.toPresentation().

---

## Template code đầy đủ

Cấu trúc thư mục sẽ như thế này:
```markdown
![Cấu trúc thư mục gợi ý](/static/images/blog/all-about-mapping-data-clean-architecture-android/structure.png)
```

```kotlin
// data.database

@Entity
data class RunEntity(
    @PrimaryKey
    val id: Long = 0,
    val distanceMeters: Long,
    val durationMillis: Long,
    val latitude: Float,
    val longitude: Float,
    val createdAt: Long
)

// data.mappers

fun RunEntity.toRun(): Run {
    return Run(
        id = id,
        distanceMeters = distanceMeters,
        duration = durationMillis.milliseconds,
        location = Location(
            latitude = latitude,
            longitude = longitude
        ),
        createdAt = Instant
            .fromEpochMilliseconds(createdAt)
            .toLocalDateTime(TimeZone.currentSystemDefault())
    )
}

fun RunDto.toRun(): Run {
    return Run(
        id = id,
        distanceMeters = distanceMeters,
        duration = durationMillis.milliseconds,
        location = Location(
            latitude = latitude,
            longitude = longitude
        ),
        createdAt = Instant
            .fromEpochMilliseconds(createdAt)
            .toLocalDateTime(TimeZone.currentSystemDefault())
    )
}

// data.network

@Serializable
data class RunDto(
    val id: Long,
    val distanceMeters: Long,
    val durationMillis: Long,
    val latitude: Float,
    val longitude: Float,
    val createdAt: Long
)

// domain.model

data class Run(
    val id: Long,
    val distanceMeters: Long,
    val duration: Duration,
    val location: Location,
    val createdAt: LocalDateTime
)

data class Location(
    val latitude: Float,
    val longitude: Float
)

// presentation.model

data class RunUi(
    val id: Long,
    val formattedDistance: String,
    val formattedDuration: String,
    val location: Location,
    val formattedCreatedAt: String
)

// presentation.mappers

fun Run.toRunUi(): RunUi {
    val distanceKm = round((distanceMeters / 1000f) / 100f) * 100f

    val totalSeconds = duration.inWholeSeconds
    val minutes = (totalSeconds / 60).toString().padStart(2, '0')
    val seconds = (totalSeconds % 60).toString().padStart(2, '0')

    return RunUi(
        id = id,
        formattedDistance = "$distanceKm km",
        formattedDuration = "$minutes:$seconds",
        location = location,
        formattedCreatedAt = createdAt.format(
            LocalDateTime.Format {
                hour()
                char(':')
                minute()
                chars(", ")
                day()
                char(' ')
                monthNumber()
                char(' ')
                year()
            }
        )
    )
}

```

Tuy nhiên trong thực tế người ta hay lược bớt UI Object mà có thể sử dụng luôn Domain Object

---

## Quy tắc chung khi implement

- Không để DTO hoặc UI Model xuất hiện trong Domain.
- Mapper nên là extension function: dễ đọc, dễ test.
- Với list: dùng map { it.asDomain() } hoặc tạo ListMapper nếu cần tái sử dụng nhiều.
- UseCase không chứa mutable state và luôn có thể test độc lập.
- Nếu dự án lớn: gom tất cả mapper vào module riêng (mappers) như trong MappersGuide.

Việc tách bạch rõ ràng Data, Domain và Presentation với mapper:

- Giúp code dễ bảo trì, dễ mở rộng.
- Giảm rủi ro khi thay đổi API hoặc UI.
- Giúp testing đơn giản hơn.

Áp dụng cấu trúc và template trên, bạn sẽ có một kiến trúc mapping rõ ràng, sạch sẽ, và dễ quản lý trong mọi dự án Android hoặc Kotlin Multiplatform.

---

### `SharedFlow`: Phù hợp hơn nhưng cần cẩn trọng

- Không giữ lại giá trị trước đó → **phù hợp với one-time event**
- Nhưng nếu chưa có ai "listening" → **event có thể bị mất**

Cách khắc phục: thiết lập `replay` hoặc `extraBufferCapacity`

---

## Channel: Giải pháp đơn giản và hiệu quả

`Channel` mang lại:

✅ Mỗi event chỉ được tiêu thụ **một lần duy nhất**  
✅ Event **xếp hàng chờ** đến khi có UI collect

```kotlin
private val _events = Channel<String>()  
val events = _events.receiveAsFlow()  

fun sendEvent() {  
    viewModelScope.launch {  
        _events.send("open_settings")  
    }  
}
```

Nhược điểm:

- Không phù hợp với mô hình MVI nghiêm ngặt
- Cần collect đúng theo vòng đời để tránh memory leak

---

## Ví dụ thực tế: Channel kết hợp với Jetpack Compose

### 1. ViewModel

```kotlin
class MainViewModel : ViewModel() {  
    private val _eventChannel = Channel<UiEvent>()  
    val eventFlow = _eventChannel.receiveAsFlow()  

    fun onButtonClick() {  
        viewModelScope.launch {  
            _eventChannel.send(UiEvent.ShowToast("Hello from ViewModel!"))  
        }  
    }  

    sealed class UiEvent {  
        data class ShowToast(val message: String) : UiEvent()  
    }  
}
```

---

### 2. Custom Composable: `EventEffect`

```kotlin
@Composable  
fun <T> EventEffect(  
    flow: Flow<T>,  
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,  
    lifecycleState: Lifecycle.State = Lifecycle.State.STARTED,  
    onEvent: (T) -> Unit  
) {  
    LaunchedEffect(lifecycleOwner, flow) {  
        lifecycleOwner.lifecycle.repeatOnLifecycle(lifecycleState) {  
            withContext(Dispatchers.Main.immediate) {  
                flow.collect { event ->  
                    onEvent(event)  
                }  
            }  
        }  
    }  
}
```

---

### 3. UI: Lắng nghe event từ Channel

```kotlin
@Composable  
fun MainScreen(viewModel: MainViewModel = viewModel()) {  
    val context = LocalContext.current  

    EventEffect(flow = viewModel.eventFlow) { event ->  
        when (event) {  
            is MainViewModel.UiEvent.ShowToast -> {  
                Toast.makeText(context, event.message, Toast.LENGTH_SHORT).show()  
            }  
        }  
    }  

    Column(  
        modifier = Modifier.fillMaxSize(),  
        verticalArrangement = Arrangement.Center,  
        horizontalAlignment = Alignment.CenterHorizontally  
    ) {  
        Button(onClick = { viewModel.onButtonClick() }) {  
            Text("Click me")  
        }  
    }  
}
```

---

### Kết quả:

- Người dùng nhấn nút → ViewModel gửi event → UI hiển thị Toast.
- Khi xoay màn hình → Toast **không bị lặp lại**.
- Event **không bị mất** nếu collect đúng cách.

---

## Tóm tắt Best Practices

| Loại dữ liệu     | Giải pháp phù hợp        |
|------------------|---------------------------|
| State dài hạn     | `StateFlow`               |
| Sự kiện một lần   | `Channel` hoặc `SharedFlow` (có buffer) |

---

## Kết luận

Không có giải pháp nào là "hoàn hảo" cho mọi dự án. Hãy chọn giải pháp **đơn giản, rõ ràng, phù hợp với kiến trúc và team của bạn**. Quan trọng nhất, đừng để one-time event trở thành *one-more-bug*!