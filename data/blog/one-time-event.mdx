---
title: 'One-Time Events trong Android: Giải Pháp Hiệu Quả với Channel'
date: '2025-05-14'
lastmod: '2025-05-14'
tags: ['android', 'architecture']
draft: false
summary: 'One-Time Events trong Android: Giải Pháp Hiệu Quả với Channel'
images: ['/static/images/twitter-card.png']
---

# One-Time Events trong Android Development: giải quyết vấn đề kinh điển

Xử lý one-time event trong Android nghe thì đơn giản, nhưng thực tế lại là một trong những bài toán kinh điển mà mọi Android developer từng gặp.

---

## One-time event là gì?

One-time event (sự kiện một lần) trong Android là những sự kiện chỉ nên được xử lý đúng **một lần duy nhất** trên giao diện người dùng (UI). Ví dụ điển hình bao gồm:

- Hiển thị một thông báo (Toast, Snackbar)
- Điều hướng sang màn hình khác (Navigation)
- Hiển thị dialog, popup, v.v.

Khác với state (trạng thái) – có thể được lưu trữ và khôi phục lại khi vòng đời Activity/Fragment thay đổi – one-time event **không nên lặp lại** khi UI được recreate (ví dụ khi xoay màn hình). Nếu không xử lý đúng, sự kiện này có thể bị lặp lại hoặc bị mất, gây ra trải nghiệm không mong muốn cho người dùng.


## Vấn Đề: Vậy tại sao one-time events lại khó đến vậy?

Hãy tưởng tượng: người dùng nhấn nút → mở màn hình mới hoặc hiện Toast. Trong lúc đó, người dùng xoay màn hình, hoặc thay đổi cấu hình thì sao?

Có một số vấn đề:

- **Lặp lại sự kiện**: ViewModel có thể phát lại event.
- **Mất sự kiện**: UI chưa kịp đăng ký đã mất event.
- **Lifecycle phức tạp**: Android quản lý vòng đời phức tạp khiến sự kiện dễ bị lặp/lạc.

Vậy làm thế nào để giải quyết những vấn đề này?

Hiện tại có một số giải pháp mà các Android developer đã sử dụng:

- LiveData & SingleLiveEvent
- StateFlow & SharedFlow
- Channel

Mỗi giải pháp có ưu và nhược điểm riêng, tùy vào từng trường hợp sẽ có cách tiếp cận khác nhau.

---

## LiveData & SingleLiveEvent: cách tiếp cận truyền thống

```kotlin

val navigationLiveData = MutableLiveData<Event<String>>()  
navigationLiveData.value = Event("go_to_profile")

```

- LiveData kết hợp `Event wrapper` giúp giới hạn UI chỉ xử lý một lần.
- Nhưng khi xoay màn hình → LiveData re-emit → lặp lại event.

### `SingleLiveEvent` khắc phục được phần nào, nhưng:

- Chỉ phát tới 1 observer → khó test & tái sử dụng
- Dễ xảy ra race condition

---

## StateFlow & SharedFlow: giải pháp hiện đại

### `StateFlow`: Lưu state tốt, nhưng dễ lặp

```kotlin

private val _stateFlow = MutableStateFlow<Event<String>?>(null)  
val stateFlow = _stateFlow.asStateFlow()  

fun triggerEvent() {  
    _stateFlow.value = Event("navigate_to_home")  
}

```

- `StateFlow` giữ lại giá trị cuối cùng → screen được recreate sẽ **nhận lại** event.
- Giải pháp: reset lại về `null`, nhưng thêm logic rườm rà.

---

### `SharedFlow`: Gần đúng nhất nhưng phải cẩn thận

- Không giữ giá trị trước đó → phù hợp với one-time event.
- Nhưng nếu không ai "listening" thì **event sẽ mất**.

Giải pháp: thiết lập `replay` hoặc `buffer` → lại thêm phức tạp.

---

## Channel: lựa chọn tối ưu

Channel đảm bảo:

✅ Mỗi event chỉ được tiêu thụ **một lần**  
✅ Event **xếp hàng chờ** cho đến khi có UI collect

```kotlin
private val _events = Channel<String>()  
val events = _events.receiveAsFlow()  

fun sendEvent() {  
    viewModelScope.launch {  
        _events.send("open_settings")  
    }  
}
```

Nhược điểm:

- Không phù hợp nếu bạn theo MVI nghiêm ngặt
- Cần cẩn thận khi collect theo Lifecycle

---

## Ví dụ thực tế: Channel trong Jetpack Compose

### 1. ViewModel

```kotlin
class MainViewModel : ViewModel() {  
    private val _eventChannel = Channel<UiEvent>()  
    val eventFlow = _eventChannel.receiveAsFlow()  

    fun onButtonClick() {  
        viewModelScope.launch {  
            _eventChannel.send(UiEvent.ShowToast("Hello from ViewModel!"))  
        }  
    }  

    sealed class UiEvent {  
        data class ShowToast(val message: String) : UiEvent()  
    }  
}
```

---

### 2. Custom Composable: `EventEffect`

```kotlin
@Composable  
fun <T> EventEffect(  
    flow: Flow<T>,  
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,  
    lifecycleState: Lifecycle.State = Lifecycle.State.STARTED,  
    onEvent: (T) -> Unit  
) {  
    LaunchedEffect(lifecycleOwner, flow) {  
        lifecycleOwner.lifecycle.repeatOnLifecycle(lifecycleState) {  
            withContext(Dispatchers.Main.immediate) {  
                flow.collect { event ->  
                    onEvent(event)  
                }  
            }  
        }  
    }  
}
```

---

### 3. UI: Nhận event từ Channel

```kotlin
@Composable  
fun MainScreen(viewModel: MainViewModel = viewModel()) {  
    val context = LocalContext.current  

    EventEffect(flow = viewModel.eventFlow) { event ->  
        when (event) {  
            is MainViewModel.UiEvent.ShowToast -> {  
                Toast.makeText(context, event.message, Toast.LENGTH_SHORT).show()  
            }  
        }  
    }  

    Column(  
        modifier = Modifier.fillMaxSize(),  
        verticalArrangement = Arrangement.Center,  
        horizontalAlignment = Alignment.CenterHorizontally  
    ) {  
        Button(onClick = { viewModel.onButtonClick() }) {  
            Text("Click me")  
        }  
    }  
}
```

---

### Kết quả

- Người dùng nhấn nút → ViewModel gửi sự kiện → UI hiển thị Toast.
- Nếu xoay màn hình → Toast không bị lặp.
- Không bị mất event nếu UI collect đúng cách.

---

## Best Practice nhanh:

- **State dài hạn** → dùng `StateFlow`
- **Event một lần** → dùng `Channel` hoặc `SharedFlow` (đã cấu hình buffer)

---

## Kết luận

Đừng cố tìm giải pháp "hoàn hảo", hãy chọn giải pháp **dễ dùng, phù hợp với team hiện tại**.